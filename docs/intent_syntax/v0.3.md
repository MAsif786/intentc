# Intent Language Specification — v0.3

> This document describes **derive expression enhancements** in v0.3. For base syntax, see [v0.1](./v0.1.md) and [v0.2](./v0.2.md).

---

## 1. Goal

Express data derivations declaratively with:
- **Predictable, deterministic, auditable** behavior
- Support for: literals, field references, pure computations, data access, system calls
- **No free-form code, loops, or arbitrary function calls**

---

## 2. General Shape

```intent
process:
    derive <identifier> = <derive-expression>
```

- `<identifier>` must be new (cannot override input or previously derived fields)
- Order matters: later derives can reference earlier ones
- Immutable: cannot reassign

---

## 3. Allowed derive-expression Forms

### A. Literal

```intent
derive status = "active"
derive count = 0
derive is_admin = false
```

- Supports: `string`, `number`, `boolean`, `null`

**Grammar (EBNF):**

```ebnf
literal := string | number | boolean | null
derive_expr := literal
```

---

### B. Field Reference

```intent
derive email_normalized =input.email
derive owner_id = user.id
```

**Can reference:**
- `input.<field>` — inputs to action
- `<derived_identifier>.<field>` — previous derives

**Cannot reference** undeclared fields.

**Grammar:**

```ebnf
field_ref := (input | derived_identifier) "." field
derive_expr := field_ref
```

---

### C. Pure Computation (compute)

```intent
derive valid = compute verify_hash(password, user.password_hash)
derive slug = compute slugify(input.name)
```

**Rules:**
- Only **registered pure functions** allowed
- Deterministic, side-effect-free
- No entity access, no I/O, no runtime state

**Grammar:**

```ebnf
compute_expr := "compute" function_name "(" arg_list ")"
derive_expr := compute_expr
arg_list := derive_expr ("," derive_expr)*
```

**Registered pure functions:**
- `verify_hash(plain, hash)` — Verify password hash
- `slugify(text)` — Convert text to URL slug
- `hash(value)` — Hash a value (internal use)
- `normalize(value)` — Normalize a string

---

### D. Data Access (select)

```intent
derive user = select User where email == input.email
derive product = select Product where id == product_id
```

**Rules:**
- Single entity only (v0.3)
- No joins, subqueries, or aggregates
- Read-only
- Must pass auth/policy validation

**Grammar:**

```ebnf
select_expr := "select" entity_name "where" predicate
predicate := field_ref ("==" | "!=" | "<" | ">") field_ref
derive_expr := select_expr
```

---

### E. System Call (system)

```intent
derive token = system jwt.create(user.email)
derive verified = system jwt.verify(token)
```

**Rules:**
- Must exist in compiler **capability registry**
- Typed (arguments & return type)
- Privileged / auditable
- Can be disabled in offline builds

**Grammar:**

```ebnf
system_expr := "system" namespace "." capability "(" arg_list ")"
derive_expr := system_expr
```

**Registered system capabilities:**
- `jwt.create(subject)` — Create JWT access token
- `jwt.verify(token)` — Verify JWT token

---

## 4. Full derive Grammar (EBNF)

```ebnf
derive_stmt := "derive" identifier "=" derive_expr

derive_expr :=
      literal
    | field_ref
    | compute_expr
    | select_expr
    | system_expr

literal := string | number | boolean | null
field_ref := (input | derived_identifier) "." field | identifier
compute_expr := "compute" function_name "(" arg_list ")"
select_expr := "select" entity_name "where" predicate
system_expr := "system" namespace "." capability "(" arg_list ")"
arg_list := derive_expr ("," derive_expr)*
predicate := field_ref ("==" | "!=" | "<" | ">") field_ref
```

---

## 5. Compiler Guarantees

### Validation

✅ Derive identifiers are unique  
✅ Field references exist  
✅ `compute` functions exist and are pure  
✅ `select` entities exist and follow policy  
✅ `system` capabilities exist in registry  

### Static Analysis

✅ Derive order analyzed for dependencies  
✅ Type compatibility checked  
✅ Auditable & deterministic  
✅ Offline builds fail if unsafe `system` is used  
✅ Pure transforms can be cached or reordered  

---

## 6. Complete Example

```intent
entity User:
    id: uuid @primary
    email: email @unique
    password_hash: string
    role: string @default("user")

@api POST /login
action login:
    input:
        email: email
        password: string
        
    process:
        derive status = "active"
        derive email_norm = input.email
        derive user = select User where email == email_norm
        derive valid = compute verify_hash(password, user.password_hash)
        derive token = system jwt.create(user.email)
        
    output: User(id, email, token)
```

**Behavior:**
1. Set status to "active" (literal)
2. Normalize email (field reference)
3. Query user by email (select)
4. Verify password (compute)
5. Create JWT token (system call)
6. Return user with token

---

## 7. Generated Python Code

The above `login` action generates:

```python
@router.post("/login")
async def login(data: LoginRequest, db: Session = Depends(get_db)):
    """login action"""
    # Query-based action
    user = db.query(UserModel).filter(UserModel.email == data.email).first()
    if not user:
        raise HTTPException(status_code=400, detail="Not found")
    if not verify_password(data.password, user.password_hash):
        raise HTTPException(status_code=400, detail="Invalid credentials")
    token = create_access_token(data={"sub": user.email})
    return {
        "id": user.id,
        "email": user.email,
        "token": token,
    }
```

---

## 8. Comparison with v0.2

**v0.2 syntax (deprecated):**

```intent
process:
    derive user = find(User, email)
    derive valid = verify_hash(password, user.password_hash)
    derive token = create_jwt(user.email)
```

**v0.3 syntax (new):**

```intent
process:
    derive user = select User where email == input.email
    derive valid = compute verify_hash(password, user.password_hash)
    derive token = system jwt.create(user.email)
```

**Key changes:**
-  `find(Entity, field)` → `select Entity where field == value`
- `verify_hash(...)` → `compute verify_hash(...)`
- `create_jwt(...)` → `system jwt.create(...)`

---

## 9. Migration Guide from v0.2

### Step 1: Identify function calls

Find all `derive` statements with function calls in your `.intent` files.

### Step 2: Categorize functions

| v0.2 Function | v0.3 Category | v0.3 Syntax |
|---------------|---------------|-------------|
| `find(Entity, field)` | **select** | `select Entity where field == input.field` |
| `verify_hash(a, b)` | **compute** | `compute verify_hash(a, b)` |
| `create_jwt(subject)` | **system** | `system jwt.create(subject)` |
| `slugify(text)` | **compute** | `compute slugify(text)` |

### Step 3: Update syntax

Replace function calls with appropriate v0.3 syntax based on the category.

### Example Migration

**Before (v0.2):**

```intent
@api POST /signup
action signup:
    input:
        email: email
        password: string @map(password_hash, hash)
    process:
        derive role = "user"
    output: User(id, email)

@api POST /login
action login:
    input:
        email: email
        password: string
    process:
        derive user = find(User, email)
        derive valid = verify_hash(password, user.password_hash)
        derive token = create_jwt(user.email)
    output: User(id, token)
```

**After (v0.3):**

```intent
@api POST /signup
action signup:
    input:
        email: email
        password: string @map(password_hash, hash)
    process:
        derive role = "user"
    output: User(id, email)

@api POST /login
action login:
    input:
        email: email
        password: string
    process:
        derive user = select User where email == input.email
        derive valid = compute verify_hash(password, user.password_hash)
        derive token = system jwt.create(user.email)
    output: User(id, token)
```

---

## 10. Future Enhancements

**v0.4 (Planned):**
- Multiple predicates in `select` (AND/OR logic)
- Aggregates: `count`, `sum`, `avg`
- Joins: `select Order join User`
- Custom compute function registration

**v0.5 (Planned):**
- Conditional derives: `derive x = if condition then value1 else value2`
- List operations: `map`, `filter`, `reduce`

---

## 11. Summary

v0.3 introduces **declarative, auditable data derivations** with:
- **Literals** for constants
- **Field references** for data access
- **Compute** for pure transformations
- **Select** for database queries
- **System** for privileged operations

All derives are:
✅ Deterministic  
✅ Auditable  
✅ Type-safe  
✅ Compiler-verified  

No hidden logic, loops, or arbitrary code.
