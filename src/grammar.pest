// Intent Definition Language Grammar (PEG)
// Parser grammar for .intent files Spec

// We DON'T use pest's implicit whitespace handling
// because we need explicit indentation matching
COMMENT = _{ "#" ~ (!"\n" ~ ANY)* }

// Explicit whitespace tokens
sp = _{ " " }
ws = _{ " " | "\t" }
nl = { "\n" | "\r\n" }
indent = _{ "    " | "\t" }

// Entry point
intent_file = { SOI ~ (nl | definition)* ~ EOI }

// Top-level definitions
definition = { auth_entity_def | entity_def | full_action_def | rule_def | policy_def }

// ============================================
// Entity Definition 
// ============================================
entity_def = {
    "entity" ~ ws+ ~ entity_name ~ ":" ~ nl ~
    entity_fields
}

// Auth Entity Definition (special single entity for authentication)
auth_entity_def = {
    "auth" ~ ws+ ~ "entity" ~ ws+ ~ entity_name ~ ":" ~ nl ~
    entity_fields
}

entity_name = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

entity_fields = { (entity_item | nl)* }

entity_item = { entity_policy | entity_field }
entity_field = { indent ~ field_def ~ nl }
entity_policy = { indent ~ nested_policy_def }

field_def = {
    field_name ~ ":" ~ ws* ~ field_type ~ (ws+ ~ decorator)*
}

field_name = @{ ASCII_ALPHA_LOWER ~ (ASCII_ALPHANUMERIC | "_")* }

// ============================================
// Type System
// ============================================
field_type = { list_type | ref_type | array_type | optional_type | base_type }

base_type = { enum_type | primitive_type | reference_type }

//  primitive types: string, number, boolean, datetime, uuid, email
primitive_type = @{ "string" | "number" | "boolean" | "datetime" | "uuid" | "email" }

enum_type = { enum_value ~ (ws* ~ "|" ~ ws* ~ enum_value)+ }

enum_value = @{ ASCII_ALPHA_LOWER ~ (ASCII_ALPHANUMERIC | "_")* }

reference_type = @{ ASCII_ALPHA_UPPER ~ (ASCII_ALPHANUMERIC | "_")* }

array_type = { "[" ~ ws* ~ base_type ~ ws* ~ "]" }

optional_type = { base_type ~ "?" }

//  composite types: ref<Entity>, list<T>
ref_type = { "ref" ~ "<" ~ ws* ~ type_name ~ ws* ~ ">" }

list_type = { "list" ~ "<" ~ ws* ~ field_type ~ ws* ~ ">" }

// ============================================
// Action Definition ( structured syntax)
// ============================================
full_action_def = {
    pre_action_decorators ~
    "action" ~ ws+ ~ action_name ~ ":" ~ nl ~
    action_body
}

pre_action_decorators = { (pre_action_decorator ~ nl)* }

pre_action_decorator = { decorator }

action_name = @{ ASCII_ALPHA_LOWER ~ (ASCII_ALPHANUMERIC | "_")* }

action_body = { 
    input_section? ~ 
    process_section? ~ 
    output_section?
}

// Input section: input fields with types and decorators
input_section = { 
    indent ~ "input:" ~ nl ~ 
    input_fields 
}

input_fields = { input_field* }

input_field = { 
    indent ~ indent ~ field_name ~ ":" ~ ws* ~ field_type ~ (ws+ ~ decorator)* ~ nl 
}

// Process section: derive statements
process_section = { 
    indent ~ "process:" ~ nl ~ 
    (process_step | indent ~ indent ~ COMMENT? ~ nl | nl)*
}

process_step = { derive_statement | mutate_block | delete_statement }

mutate_block = {
    indent ~ indent ~ "mutate" ~ ws+ ~ type_name ~ (ws+ ~ "where" ~ ws+ ~ predicate)? ~ ":" ~ nl ~
    mutate_setters
}

mutate_setters = { (mutate_setter | indent ~ indent ~ indent ~ COMMENT? ~ nl | nl)* }

mutate_setter = {
    indent ~ indent ~ indent ~ "set" ~ ws+ ~ field_name ~ ws* ~ "=" ~ ws* ~ derive_expr ~ nl
}

delete_statement = {
    indent ~ indent ~ "delete" ~ ws+ ~ type_name ~ ws+ ~ "where" ~ ws+ ~ predicate ~ nl
}

derive_statement = { 
    indent ~ indent ~ "derive" ~ ws+ ~ identifier ~ ws* ~ "=" ~ ws* ~ derive_expr ~ nl 
}

// Derive expression: compute, select, system call, dotted path, literal, or identifier
derive_expr = { compute_expr | select_expr | system_expr | dotted_path | literal | identifier }

// Compute expression: compute function_name(args)
compute_expr = { "compute" ~ ws+ ~ identifier ~ "(" ~ ws* ~ function_args? ~ ws* ~ ")" }

// Select expression: select Entity where predicate
select_expr = { "select" ~ ws+ ~ type_name ~ ws+ ~ "where" ~ ws+ ~ predicate }

// System call expression: system namespace.capability(args)
system_expr = { "system" ~ ws+ ~ namespace ~ "." ~ identifier ~ "(" ~ ws* ~ function_args? ~ ws* ~ ")" }
namespace = @{ ASCII_ALPHA_LOWER ~ (ASCII_ALPHANUMERIC | "_")* }

// Predicate for select: derive_field_ref op derive_field_ref
predicate = { derive_field_ref ~ ws* ~ compare_op ~ ws* ~ derive_field_ref }
derive_field_ref = { dotted_path | literal | identifier }
compare_op = @{ "==" | "!=" | "<" | ">" }

// Function arguments (used by compute and system)
function_args = { function_arg ~ (ws* ~ "," ~ ws* ~ function_arg)* }
function_arg = { dotted_path | type_name | literal | identifier }

dotted_path = { path_segment ~ ("." ~ path_segment)+ }
path_segment = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

// Output section: entity projection
output_section = { 
    indent ~ "output:" ~ ( (ws* ~ nl ~ indent ~ indent ~ type_projection ~ nl) | (ws+ ~ type_projection ~ nl) )
}

type_projection = { type_name ~ "(" ~ ws* ~ projection_fields ~ ws* ~ ")" }

projection_fields = { identifier ~ (ws* ~ "," ~ ws* ~ identifier)* }

// ============================================
// Rule Definition
// ============================================
rule_def = {
    "rule" ~ ws+ ~ rule_name ~ ":" ~ nl ~
    indent ~ when_clause ~ nl ~
    indent ~ then_clause ~ nl?
}

rule_name = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

when_clause = { "when" ~ ws+ ~ expression }
then_clause = { "then" ~ ws+ ~ consequence }

// ============================================
// Policy Definition
// ============================================
policy_def = {
    "policy" ~ ws+ ~ policy_name ~ ":" ~ nl ~
    indent ~ "subject" ~ ":" ~ ws+ ~ subject_name ~ nl ~
    indent ~ "require" ~ ws+ ~ expression ~ nl
}

nested_policy_def = {
    "policy" ~ ws+ ~ policy_name ~ ":" ~ nl ~
    indent ~ indent ~ "subject" ~ ":" ~ ws+ ~ subject_name ~ nl ~
    indent ~ indent ~ "require" ~ ws+ ~ expression ~ nl
}

policy_name = @{ ASCII_ALPHA_UPPER ~ (ASCII_ALPHANUMERIC | "_")* }
subject_name = { auth_subject | entity_subject }
auth_subject = @{ "@auth" }
entity_subject = @{ ASCII_ALPHA_UPPER ~ (ASCII_ALPHANUMERIC | "_")* }

// ============================================
// Decorators
// ============================================
decorator = { "@" ~ decorator_type }

decorator_type = {
    api_decorator | validate_decorator | default_decorator | 
    map_decorator | auth_decorator | policy_decorator | simple_decorator
}

// @policy(Name) or @policy(Entity.Name)
policy_decorator = { "policy" ~ "(" ~ ws* ~ policy_target ~ ws* ~ ")" }
policy_target = { type_name ~ ("." ~ type_name)? }

// Simple single-word decorators
simple_decorator = @{ "primary" | "unique" | "optional" | "index" | "auto" }

// @auth or @auth(Entity) or @auth(validate_user(id))
auth_decorator = { "auth" ~ ("(" ~ ws* ~ auth_target ~ ws* ~ ")")? }
auth_target = { identifier ~ "(" ~ ws* ~ auth_args? ~ ws* ~ ")" | type_name | identifier }
auth_args = { identifier ~ (ws* ~ "," ~ ws* ~ identifier)* }

// @api METHOD /path
api_decorator = { "api" ~ ws+ ~ http_method ~ ws+ ~ api_path }
http_method = @{ "GET" | "POST" | "PUT" | "PATCH" | "DELETE" }
api_path = @{ "/" ~ (ASCII_ALPHANUMERIC | "/" | "_" | "-" | "{" | "}")* }

// @default(value)
default_decorator = { "default" ~ "(" ~ ws* ~ default_value ~ ws* ~ ")" }
default_value = { string_literal | number_literal | boolean_literal | identifier }

// @map(target_field, transform) with transform
map_decorator = { "map" ~ "(" ~ ws* ~ identifier ~ ws* ~ ("," ~ ws* ~ transform_type ~ ws*)? ~ ")" }
transform_type = @{ "none" | "hash" }

// @validate(min: 1, max: 100, pattern: "...")
validate_decorator = { "validate" ~ "(" ~ ws* ~ validate_args ~ ws* ~ ")" }
validate_args = { validate_arg ~ (ws* ~ "," ~ ws* ~ validate_arg)* }
validate_arg = { validate_key ~ ws* ~ ":" ~ ws* ~ validate_value }
validate_key = @{ "min" | "max" | "pattern" | "required" }
validate_value = { string_literal | number_literal | boolean_literal }

// ============================================
// Expressions
// ============================================
expression = { or_expr }

or_expr = { and_expr ~ (ws+ ~ "or" ~ ws+ ~ and_expr)* }
and_expr = { not_expr ~ (ws+ ~ "and" ~ ws+ ~ not_expr)* }
not_expr = { ("not" ~ ws+)? ~ comparison }
comparison = { primary ~ (ws* ~ comp_op ~ ws* ~ primary)? }

comp_op = @{ "==" | "!=" | ">=" | "<=" | ">" | "<" }

primary = { paren_expr | field_access | literal | identifier }

paren_expr = { "(" ~ ws* ~ expression ~ ws* ~ ")" }

field_access = { (subject_prefix | entity_ref) ~ "." ~ field_ref }
subject_prefix = @{ "subject" }
entity_ref = @{ ASCII_ALPHA_UPPER ~ (ASCII_ALPHANUMERIC | "_")* }
field_ref = @{ ASCII_ALPHA_LOWER ~ (ASCII_ALPHANUMERIC | "_")* }

literal = { string_literal | number_literal | boolean_literal }
string_literal = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
number_literal = @{ "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
boolean_literal = @{ "true" | "false" }

identifier = @{ ASCII_ALPHA_LOWER ~ (ASCII_ALPHANUMERIC | "_")* }

type_name = @{ ASCII_ALPHA_UPPER ~ (ASCII_ALPHANUMERIC | "_")* }

// ============================================
// Consequences
// ============================================
consequence = { reject_call | log_call | action_call }

reject_call = { "reject" ~ "(" ~ ws* ~ string_literal ~ ws* ~ ")" }
log_call = { "log" ~ "(" ~ ws* ~ string_literal ~ ws* ~ ")" }
action_call = { identifier ~ "(" ~ ws* ~ call_args? ~ ws* ~ ")" }
call_args = { call_arg ~ (ws* ~ "," ~ ws* ~ call_arg)* }
call_arg = { expression }
